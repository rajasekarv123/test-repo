{"jsonrpc":"2.0","id":0,"result":{"qScript":"///$tab Initialize\r\n//\tLicense Monitor\r\nLET yr\t\t\t= year(ReloadTime());\r\nSET copyright = 'Copyright 1993-$(yr) Qliktech International AB';\r\n\r\n// Messaging and QVD file name variables\r\nLet ReloadStartTime \t\t= now(1);\r\nSet ahora = ; SET msg =; SET skipped=0; SET loaded =0; SET textFile =;\t// Reset these variables\r\nSET app_name\t\t\t\t= 'License Monitor';\r\nSET app_version\t\t\t\t= '7.19.0';\r\nLet comp \t\t\t\t\t= ComputerName(); \r\nLET EngineVer = PurgeChar(EngineVersion(),chr(39)); \r\nLET startMsg\t\t\t\t= 'Reloading $(app_name) $(app_version) from $(comp) running QIX Engine version $(EngineVer)';\r\nTRACE $(startMsg);\r\n\r\n// Runtime date/time variables\r\nSET monthsOfHistory \t\t= 12;\t\t// How many months of history should be available in the app. More history = more processing, bigger app, etc.\r\nLET cutoffDate \t\t\t\t= AddMonths(today(),-$(monthsOfHistory),1);\t\t// Filter individual .log files and baseTable; note: the 1 \r\nLet LastReloadTime \t\t\t= timestamp(if(isnull(LastSuccessfulReloadStartTime),cutoffDate,LastSuccessfulReloadStartTime));\r\nLet lastReloadCompare \t\t= num(LastReloadTime)-1;\t// (Re-)load any logs updated within 24 hours of the last reload\r\nSET minSenseActivityDate\t= 42005;\t// Jan 1, 2015 - cutoff for all Sense-related activity\r\n\r\n// Miscellaneous\r\nSET hideprefix \t\t\t\t= 'log';\t// Hiding logList from view, though preserving it for now (not dropping it)\r\nSET firstReload \t\t\t= 0;\t\t// RESET this each time -- it will check.\r\nSET va_LoginToUserPass\t\t= 10;\t\t// How many Login Access sessions = 1 token\r\nSET va_analyzer_capacity_consumption_minutes\t= 6;\t// How many minutes for each Analyzer Capacity unit of consumption? Default = 6.\r\nSET va_analyzer_capacity_message = '';\t// Reset this each reload\r\nSET vs_analyzer_capacity_Allocated =; SET vs_analyzer_capacity_Used = ; SET vs_analyzer_capacity_Unavailable = ;\t// reset these\r\nSET va_analyzer_capacity_help_link = 'https://help.qlik.com/en-US/search/?q=analyzer+capacity+license';\r\n\r\n// Data connection & file name variables\r\nLET serverLogFolder\t\t\t= 'lib://ServerLogFolder/';\t\r\nLET archivedLogsFolder\t\t= 'lib://ArchivedLogsFolder/';\r\nSET central_node_name\t\t=  ;\t// Multinode intialize\r\n\r\nLET baseFileName\t \t\t= 'governanceLicenseLog_$(app_version)';\t\r\nLET baseTableName \t\t\t= '$(serverLogFolder)$(baseFileName)';\r\n\r\nLET SessionFileName \t\t= 'governanceSession_$(app_version)';\r\nLET sessionTableName\t\t= '$(serverLogFolder)$(SessionFileName)';\r\nLET monitorAppStatsFile\t\t= '$(serverLogFolder)License_Monitor_Reload_Stats_$(app_version).txt';\r\n\r\nSET storeBaseTableFail \t\t= 0;\t\t// If script fails to store base table, set to 1 and do not update LastSuccessfulReloadStartTime variable\r\nLET tempErrorDetails \t\t=  ;\r\n\r\n// Set date and time formats\r\nSET TimeFormat\t\t= 'hh:mm:ss';\r\nSET DateFormat\t\t= 'YYYY-MM-DD';\r\nSET TimestampFormat\t= 'YYYY-MM-DD hh:mm:ss';\r\n// Calendar Variables\r\nLet vLast72Hours =\tNum(timestamp(Now(1)-3));\r\nLet vLast7Days  = Num(timestamp(Now(1)-7));\r\nLet vLast14Days  = Num(timestamp(Now(1)-14));\r\nLet vLast28Days  = Num(timestamp(Now(1)-28));\r\nLet vLast90Days  = Num(timestamp(Now(1)-90));\r\n\r\n// Colors\r\nset c_red\t\t\t\t\t= 'RGB(204,102,119)';\r\nset c_yellow\t\t\t\t= 'RGB(221,204,119)';\r\nset c_blue\t\t\t\t\t= 'RGB(68,119,170)';\r\nset c_green\t\t\t\t\t= 'RGB(17,119,51)';\r\nset c_gray \t\t\t\t\t= 'RGB(150,150,150)';\r\nset c_lightred \t\t\t\t= 'RGB(240,209,214)';\r\nset c_lightblue \t\t\t= 'RGB(188,181,201)';\r\n//// ARGB colors -- requires input value to set the intensity (alpha) value of the color. Example using field [dual90]:  $(c_red_alpha(dual90))\r\nset c_red_alpha\t\t\t\t= 'ARGB($1,204,102,119)';\r\nset c_orange_alpha\t\t\t= 'ARGB($1,233,141,54)';\r\nset c_yellow_alpha\t\t\t= 'ARGB($1,221,204,119)';\r\nset c_blue_alpha\t\t\t= 'ARGB($1,68,119,170)';\r\nset c_green_alpha\t\t\t= 'ARGB($1,17,119,51)';\r\nset c_gray_alpha\t\t\t= 'ARGB($1,150,150,150)';\r\nset c_red_breeze_alpha\t\t= 'ARGB($1,155,58,59)';\r\nset c_orange_breeze_alpha\t= 'ARGB($1,233,141,54)';\r\nset c_teal_breeze_alpha\t\t= 'ARGB($1,19,118,122)';\r\nset c_green_breeze_alpha\t= 'ARGB($1,101,177,99)';\r\nset c_red_0_green_alpha\t\t= 'If($1=0,c_red,ARGB($1,101,177,99))';\r\n\r\n///$tab logList\r\nSUB logList\r\n\r\n\tlogList:\r\n    LOAD * INLINE [\r\n    \tlogService, logArea, logType, logStart, logAddlFields,logAddlFilter\r\n        Repository, Audit, Security,Timestamp,fieldsAuditSecurity,additionalFilterAuditSecurity\r\n\r\n     ];\r\nENDSUB\r\n\r\n///$tab defineFields\r\nSUB defineFields\r\n\t// End each variable definition (list of fields) with a comma //\r\n  // Common Fields are defined on the loadFiles\r\n  \r\n  LET fieldsAuditSecurity \t\t= '';\r\n\r\nENDSUB\r\n\r\n\r\n///$tab CommandList\r\nSUB CommandList\r\n\r\n  CommandList:\t//This is the list (with exception of special \"Rule\" commands) that will be loaded into this app\r\n  LOAD \r\n      Command, \r\n      CommandType\r\n  Inline [\r\n    Command, CommandType\r\n    Add license, Allocation\r\n    Add user access, Usage\r\n    Delete user access, Allocation\r\n    License maintenance, Usage\r\n    License user access, Usage\r\n    License user access request, Usage\r\n    Request access type, Usage\r\n    Update license, Allocation\r\n    Update user access, Allocation\r\n    ];\r\n\r\nENDSUB\r\n\r\n///$tab loadBaseTable\r\nSUB loadBaseTable (nombre, archivo)\r\n\t// Check to see if governanceLicenseContents (LogContent) qvd exists\r\n\tLet baseFileSize = FileSize('$(archivo).qvd');\r\n\r\n    IF  baseFileSize > 0 THEN \t    // Yes - QVD exists = not first load\r\n\r\n\t\ttrace Incremental reload (not first reload);\r\n    \tLet firstReload = 0;\r\n        \r\n        $(nombre):\r\n        NoConcatenate\r\n    \tLoad * FROM $(archivo).qvd (qvd)\r\n        WHERE LogTimeStamp >= '$(cutoffDate)'\r\n        ;\r\n        \r\n        LET tempErrorDetails = ScriptErrorDetails;\r\n        IF Len(tempErrorDetails)>0 THEN\r\n          CALL monitor_app_reload_stats('WARN','$(archivo)', tempErrorDetails,'Status Message')\r\n\t\t  tempErrorDetails = ;\t// Reset this\r\n        END IF\r\n        \r\n    ELSE\t\t// No - no QVD exists = First (initial) load\r\n        \r\n        trace Initial Load for $(nombre);\r\n        Let firstReload = 1;\r\n        LET lastReloadCompare\t\t= num(cutoffDate);\t//num('2014-01-01');\t// If First reload, do not filter logs by LastReload\r\n        Let LastReloadTime \t\t\t= timestamp(cutoffDate);\r\n       \r\n        IF nombre = 'LogContent' THEN\t// License Repository log data\r\n          $(nombre):\r\n          NoConcatenate\r\n          Load * Inline [Id, LogEntryPeriodStart, LogTimeStamp,Hostname,Message\t\t\t\r\n                          ];\r\n        ELSEIF nombre = 'sessionData' THEN \t// nombre = 'sessionData' > Session_Engine log data\r\n          $(nombre):\r\n          NoConcatenate\r\n          Load * Inline [ProxySessionId,LogTimeStamp]; \r\n       ELSEIF WildMatch('$(nombre)','qlikview*') = 1 THEN // for QlikView Server and QlikView Event logs; dual-use license consumption analysis only\r\n          $(nombre):\r\n          NoConcatenate\r\n          Load * Inline [SessionId,LogTimeStamp]; \r\n          // Note: this table will be dropped if no qlikview logs are fetched.\r\n        ELSE \t\t\t\r\n        \tTRACE Error in loadBaseTable subroutine.;\r\n        END IF\r\n        \r\n    END IF\r\n    \r\n    LET NoOfRows$(nombre)BASE = NoOfRows('$(nombre)');\r\n    \r\nENDSUB\r\n\r\n///$tab multiNodeConfig\r\nSUB multiNodeConfig\t\t\r\n\t// Check for multi-node environment by verifying files in Repository\\ArchivedLogs folder\r\n\t\r\n    FOR each folder in DirList(archivedLogsFolder & '*')\r\n      node_list:\r\n      Load\r\n        '$(folder)'&'\\' as folder,\r\n        mid('$(folder)',26) as [Node Name],\r\n        FileTime( '$(folder)' ) as folder_Time\r\n      AutoGenerate 1;\r\n      \r\n\tNEXT folder\r\n    \r\n    LET count_of_nodes\t= NoOfRows('node_list');\r\n    \r\n    IF count_of_nodes > 1 then\r\n    \tLET multiNode = 'Multi-Node';\r\n        TRACE Multi-Node environment detected;\r\n    ELSE\r\n        LET multiNode = 'Single-Node';\r\n        TRACE Single-Node environment detected;\r\n        let count_of_nodes = If(isnull(count_of_nodes),0,1);\r\n    ENDIF\r\n\r\nEndSub\r\n\r\n///$tab logFolderList\r\nSUB logFolderList\r\n        \r\n  // Create a list of folders to search for log files, including all folders in the ..\\Sense\\Repository\\ArchivedLogs folder\r\n  // For Multi-node configuration, please refer to the instructions below\r\n  FOR each node in 'ServerLogFolder'\r\n  \r\n      LET svr = 'lib://$(node)/';  \r\n      \r\n      logFolderList:\r\n      LOAD\r\n        '$(svr)' as mainLogFolder,\r\n          'txt' as file_extension\r\n      AutoGenerate(1);\r\n      \r\n  NEXT node    \r\n\r\n  FOR each fldr in DirList('$(archivedLogsFolder)'&'*')\r\n      Concatenate (logFolderList)\r\n      Load\r\n             '$(fldr)/' as mainLogFolder,\r\n          'log' as file_extension\r\n      AutoGenerate(1);        \r\n  \r\n  NEXT fldr\r\n  \r\n  /* =========== Instructions for Multi-node configuration\t==================================================================================\\\\\r\n  \r\n\t1.\tAdd new data connection for each rim node. If you have 5 RIM nodes, you will need to create 5 data connections. \r\n\t\tFor example, data connection for RIM1 points to folder \\\\rim_node_1\\c$\\programdata\\qlik\\sense\\log and is called RIM1\r\n\r\n\t2.\tRename new data connections in QMC to remove the (username) which is appended to the data connection name --- Example RIM1 (user_183)\r\n\r\n\t3.\tUpdate load script in section SUBT logFolderList on line 5 by adding the names of all new data connections created in step 1 and 2. \r\n    \tEach new data connection name should be enclosed in single quotes ' and separated by a comman. For example:\r\n        \tFOR each node in 'ServerLogFolder','RIM1','RIM2'\r\n\r\n\t4.\tPerform Step 3 in the other Monitor App\r\n    \r\n  /* ===========================================================================================================================================*/  \r\n\r\nENDSUB\r\n\r\n///$tab loadFiles\r\nSUB loadFiles (fdr,iter)\r\n  // Use the iteration number (on Run Logic section) to load all log files listed in the logList SUB\r\n  Let carpeta\t\t\t= peek('mainLogFolder',$(fdr),'logFolderList');\r\n  Let extension\t\t\t= peek('file_extension',$(fdr),'logFolderList');\r\n  Let logService \t\t= peek('logService',$(iter),'logList');\r\n  Let logArea\t \t\t= peek('logArea',$(iter),'logList');\r\n  Let logType\t \t\t= peek('logType',$(iter),'logList');\r\n  Let logAddlFields\t\t= peek('logAddlFields',$(iter),'logList');\r\n  LET logName \t\t\t= '$(carpeta)$(logService)\\$(logArea)\\*$(logType)';\r\n  LET addlFilter1\t\t= peek('logAddlFilter',$(iter),'logList');\r\n  LET additionalFilter\t= $(addlFilter1);\r\n\r\n  // Log-specific fields spelled out in the SUB defineFields\r\n  LET fields2Load \t\t= $(logAddlFields);\r\n  \r\n  // Session and TaskExecution log files have a start and stop timestamp;  all other logs use Timestamp as start and stop, per the logList table\r\n  LET logStartTS\t= 'Timestamp(\"' & peek('logStart',$(iter),'logList') &'\")';\r\n\r\n  for each textFile in FileList(logName & '*.' & extension)\r\n  \r\n    // Only load the files updated since the last reload\r\n    If FileTime( '$(textFile)' ) >= $(lastReloadCompare) then\r\n    //working:\r\n      CONCATENATE (working)  \r\n      LOAD\r\n        $(logStartTS) AS LogEntryPeriodStart,\r\n        Timestamp(\"Timestamp\") as LogTimeStamp,\r\n        lower(Hostname) as Hostname,\r\n\t\tDescription,\t\t\r\n        ProxySessionId,\r\n        ProxyPackageId,\r\n        RequestSequenceId,\r\n        ProxySessionId&ProxyPackageId as _proxySessionPackage,\r\n        Message,\r\n\t\tService,\r\n        Context,\r\n        Command,\r\n        Result,\r\n        ProductVersion,\r\n        ObjectId,\r\n        ObjectName,\r\n        UserDirectory,\r\n        LOWER(UserDirectory & '\\' & UserId) as UserId,\t// To link to qrs user data\r\n        // For Audit Security Log only! If additional logs are added, move this back to the \"defineFields\" SUB\r\n        SecurityClass,\r\n        If(Result=0 or (Result >=200 and Result <=226),dual('OK',0), if(Result=' ',dual('Blank',0), dual('NOK',1))) as Status,        \r\n        IF(WildMatch(Message,'* access granted*')>0,\r\n        \tIf(Command='License analyzer time access','Analyzer Capacity',SubField(Message,' ',1))) as [Access Type], \r\n        Ceil(Num(TextBetween(Message,'Duration: ' & chr(39),Chr(39) & ' (sec')/60),$(va_analyzer_capacity_consumption_minutes)) as [Analyzer Capacity Used (Minutes)],\r\n        If(WildMatch(Message,'professional access gr*','analyzer access gr*','analyzertime access gr*','analyzer time access gr*')>0,'Sense') as [Unified Licensing Product],\r\n        IF(WildMatch(Message,'* access granted*')>0,Date(Floor(\"Timestamp\"))) as [Access Date],\r\n        IF(Result=403,1) as UsageDenied,\r\n        IF(Result=403,TextBetween(Message,'AccessID ',',')) as usage_denied_access_id,\r\n        IF(left(Message,20)='Login access granted',purgechar(TextBetween(Message,'UsageID: ',','),chr(39))) as UsageId,\t// for login pass usage, count(Distinct UsageId)\r\n        IF(left(Message,20)='Login access granted',purgechar(TextBetween(Message,'Accessname: ',','),chr(34)&chr(39)),\r\n            IF(left(Message,24)='Login access for license',purgechar(TextBetween(Message,' Name: ',','),chr(34)&chr(39)))) as [Login Access Rule],\r\n        IF(((Context='/qrs/licenseadd' and not Origin = 'ManagementAccess') OR Context='/qrs/licenseupdate' or Context='/qrs/license/datamarket')\r\n            OR WildMatch(Command,'Add * access','Update * access','Delete license')>0  \r\n            OR (index(lower(ObjectName),'license')>=1  AND WildMatch(Command,'Add rule','Update rule','Delete rule')>0),\r\n            1) as [License Allocation],\t\t\t\t\t\t\t\t\t\t\t\t\t// To track Allocations\r\n\r\n        IF(Context='/qrs/license/datamarket','DataMarket License',\r\n            IF(Context='/qrs/licenseadd' and Origin = 'ManagementAccess',null(),//SKIP THIS extra entry for Data Market license addition\r\n                IF(Context='/qrs/licenseadd' OR Context='/qrs/licenseupdate','Site License',\r\n                    IF(left(Message,24)='Login access for license',purgechar(TextBetween(Message,' Name: ',','),chr(34)&chr(39)),\r\n                        ObjectName)))) as [Affected Entity],\r\n        //        $(fields2Load)    \t// Currently empty for just Audit Security Log\r\n        Id as Id_temp\t\t// Unique Identifier for Log entry to be used in the WHERE NOT EXISTS () clause to avoid loading duplicate log entries\r\n                        \r\n      FROM '$(textFile)'\r\n      (txt, utf8, embedded labels, delimiter is '\\t', msq)\r\n          WHERE isnum(Sequence#)\r\n           AND (exists(Command)\t\r\n                OR (index(lower(ObjectName),'license')>=1  AND (Command = 'Add rule' or Command = 'Update rule' or Command = 'Delete rule'))\r\n                OR SecurityClass = 'License');\r\n      \r\n      // If there is an error in the loading of the log, send a trace message about it\r\n      LET tempErrorDetails = ScriptErrorDetails;\r\n      IF Len(tempErrorDetails) > 0 THEN\r\n        trace ERROR: $(tempErrorDetails);\r\n        CALL monitor_app_reload_stats('WARN','$(textFile)', tempErrorDetails, 'Status Message')\r\n        tempErrorDetails =;\t// Reset this variable\r\n      END IF\r\n      \r\n    ENDIF\r\n  \r\n  next textFile\r\n\r\nENDSUB\r\n///$tab concatTables\r\nSUB concatTables (concatToTable, incrementalTable, concatField)\r\n\r\n  TRACE Concatenating tables...;\r\n  \r\n  Let rows$(incrementalTable)Final = num(NoOfRows('$(incrementalTable)'),'#,##0');\r\n  trace $(rows$(incrementalTable)Final) incremental rows loaded;\r\n  \r\n  IF NoOfRows('$(incrementalTable)')>0 then\r\n  \r\n    IF concatToTable = 'LogContent' THEN\t\r\n      CONCATENATE ($(concatToTable))\r\n      LOAD \r\n          *, \r\n          $(concatField)_temp as $(concatField),\r\n          (round(num(LogEntryPeriodStart),0.0006)&'|'&round(num(LogTimeStamp),0.0006)) as _TimeDIM_Link\t// to link w/ datetime table\r\n      RESIDENT $(incrementalTable)\r\n          WHERE NOT Exists ($(concatField),$(concatField)_temp);\r\n  \r\n    ELSE\t// sessionData does no have LogEntryPeriodStart field\r\n  \r\n      CONCATENATE ($(concatToTable))\r\n      LOAD \r\n          *, \r\n          $(concatField)_temp as $(concatField)\r\n      RESIDENT $(incrementalTable)\r\n          WHERE NOT Exists ($(concatField),$(concatField)_temp);\r\n      \r\n    END IF\r\n    \r\n    drop field $(concatField)_temp from $(concatToTable);\r\n    \r\n  ELSE\r\n    Trace No incremental rows for $(incrementalTable);  // Should only ever occur if all Qlik Services are stopped  \r\n  \r\n  ENDIF\r\n  \r\n    drop table $(incrementalTable);\r\n\r\nENDSUB\r\n\r\n///$tab sessionData\r\nSUB sessionData  (fdr)\r\n\r\n  // Initialize & Setup\r\n  Let carpeta\t\t\t= peek('mainLogFolder',$(fdr),'logFolderList'); \r\n  LET logName \t\t\t= '$(carpeta)Repository\\Audit\\*Activity';\r\n  Let extension\t\t\t= peek('file_extension',$(fdr),'logFolderList');\r\n  \r\n  for each textFile in FileList(logName & '*.' & extension)\r\n    \r\n    // Only load the files updated since the last reload\r\n    If FileTime( '$(textFile)' ) >= $(lastReloadCompare) then\r\n    \r\n      CONCATENATE (working_session)\r\n      Load\r\n      \tProxySessionId,\r\n        ProxySessionId&ObjectId as proxy_session_id_app_id,\t\t// count(distinct proxy_session_id_app_id) for surrogate \"Session Count\" in this app\r\n        timestamp(Timestamp(Timestamp#(Replace(Left(Timestamp,15),'T',' '), 'YYYYMMDD hhmmss')),'YYYY-MM-DD hh:mm:ss[.fff]') AS LogTimeStamp,\r\n        ObjectId as AppId,\r\n        ObjectName as [App Name],\r\n        Id as Id_temp\t\t// Unique Identifier for Log entry to be used in the WHERE NOT EXISTS () clause to avoid loading duplicate log entries\r\n      \r\n      FROM '$(textFile)' \r\n      (txt, utf8, embedded labels, delimiter is '\\t', msq)\r\n       WHERE left(Command,8) = 'Open app'\r\n            AND ProxySessionId <> 0\t// 0 entries are for sa_repository and sa_scheduler\r\n      ;\r\n      \r\n      // If there is an error in the loading of the log, send a trace message about it\r\n      LET tempErrorDetails = ScriptErrorDetails;\r\n      IF Len(tempErrorDetails) > 0 THEN\r\n        trace ERROR: $(tempErrorDetails);\r\n        CALL monitor_app_reload_stats('WARN','$(textFile)', tempErrorDetails,'Status Message')\r\n\t\ttempErrorDetails = ;\r\n      END IF\r\n\r\n    ENDIF\r\n  \r\n  next textFile\r\n\r\nENDSUB\r\n\r\n///$tab storeFiles\r\nSUB storeFiles (nombre, archivo)\r\n\r\n  \tStore '$(nombre)' into [$(archivo).qvd];\r\n    \r\n    LET tempErrorDetails = ScriptErrorDetails;\r\n  \tIF LEN(tempErrorDetails) > 0 THEN\r\n    \tSET storeBaseTableFail = 1;\r\n        CALL monitor_app_reload_stats('WARN','$(archivo)', tempErrorDetails, 'Status Message')\r\n\t\ttempErrorDetails = ; \t// Reset This\r\n  \tELSE\r\n    \tSET storeBaseTableFail = 0;\r\n    END IF\r\n      \r\n    LET NoOfRowsLogContent = num(NoOfRows('$(nombre)'),'#,##0');\r\n    LET NoOfRowsIncremental = NoOfRowsLogContent - NoOfRowsLogContentBASE;\r\n    Let storeTime = now(1);\r\n    TRACE $(nombre) table stored at $(storeTime) with $(NoOfRowsLogContent) rows;\r\n\r\nENDSUB\r\n\r\n///$tab monitor_app_reload_stats\r\nSUB monitor_app_stats_incremental\t// Use this to append new 'status' entry to table  \r\n    Concatenate (monitor_app_reload_stats)\r\n    Load\r\n      RowNo() as [Log Entry],\r\n      timestamp(now(1)) as [Log Timestamp],\r\n      '$(sev)' as [Log Severity],\r\n      '$(comp)' as Host,\r\n      '$(description)' as Description,\r\n      '$(message)' as [Log Message],\r\n      '$(obj)' as Object\r\n    AutoGenerate (1);\r\n    \r\nENDSUB\r\n   \r\nSUB monitor_app_reload_stats (sev, obj, message, description)\r\n  \r\n  IF description = 'Reload Start' THEN\r\n  \t// Check for existing base status file\r\n\tIF FileSize('$(monitorAppStatsFile)') > 0 THEN\r\n      monitor_app_reload_stats:\r\n      Load * From '$(monitorAppStatsFile)' (txt, utf8, embedded labels, delimiter is '\\t', msq);\r\n    ELSE\r\n      Trace Did not find $(monitorAppStatsFile) - will create a new file.;\r\n      monitor_app_reload_stats:\r\n      Load * Inline [Log Entry, Log Timestamp, Log Severity,Host,Description,Log Message,Object];\r\n    ENDIF\r\n\r\n    Let appMonitorStatsRowsInit = NoOfRows('monitor_app_reload_stats');\r\n    CALL monitor_app_stats_incremental\t\t// Add start message\r\n  \r\n  ELSEIF description = 'Status Message' THEN    \r\n    CALL monitor_app_stats_incremental\t\t// Add status message\r\n    \r\n  ELSEIF description = 'Reload Finish' THEN\r\n  \tCALL monitor_app_stats_incremental\t\t// Add Finish message\r\n    STORE monitor_app_reload_stats into '$(monitorAppStatsFile)' (txt, delimiter is '\\t');\r\n    DROP TABLE monitor_app_reload_stats; \r\n  \r\n  ELSE\r\n  \ttrace Something went wrong with the monitor app reload status messaging.;\r\n  \r\n  ENDIF\r\n\r\nENDSUB\r\n\r\n///$tab QRS\r\nSUB QRS\r\n\t// Here we load data from Qlik Sense Repository (QRS) database \r\n    // If the connection fails (missing REST connector, can't connect to QRS) - the load script will fail :(\r\n    //\tAlso, if no data is returned from the QRS, the load script will terminate as well because there is something wrong to be investigated :(\r\n    LET NumRowsQRS = 0;\r\n    SET QRS_RowCounts = 'QRS Row Counts: ';\r\n    \r\n    For each endpoint in 'monitor_apps_REST_license_user','monitor_apps_REST_license_login','monitor_apps_REST_user','monitor_apps_REST_license_access','monitor_apps_REST_app','monitor_apps_REST_license'\r\n    \tCALL $(endpoint)\r\n        DisConnect;\r\n\t\tLET rose\t\t\t= evaluate(NumRows_$(endpoint));\r\n        LET rose\t\t\t= if(isnull(rose),0,rose);\r\n        LET NumRowsQRS\t\t= $(NumRowsQRS) + $(rose);\r\n        LET QRS_RowCounts \t= '$(QRS_RowCounts) $(endpoint) = $(rose) lines,';\r\n    Next endpoint\r\n\r\n\tIf NumRowsQRS > 0 Then\r\n    \tCALL monitor_app_reload_stats('INFO','License Monitor', '$(QRS_RowCounts)','Status Message')\r\n        TRACE Reload Status: $(QRS_RowCounts);\r\n    ELSE\t// No data fetched from QRS! This throws an error message, but will not fail the reload\r\n   \t\tLET msg_qrs =  'There was a problem fetching data from QRS via the REST connector. We could connect, but failed to fetch data. $(QRS_RowCounts)';\r\n   \t\tCALL monitor_app_reload_stats('ERROR','License Monitor', msg_qrs,'Status Message')\r\n        // This msg_qrs message will be reported on the Log Details page\r\n    ENDIF\r\n \r\nENDSUB\r\n///$tab license_user\r\nSUB monitor_apps_REST_license_user\r\n  Set NumRows_monitor_apps_REST_license_user = 0;\t// Reset this\r\n  \r\n  License_User_Access_Types:\r\n  NoConcatenate Load * Inline [UserId];\r\n\r\n  For Each tipo in 'User','Professional','Analyzer'\r\n  \tLET f_unused = '[Unused UserId' & if(tipo='user',']',' $(tipo)]');\r\n    LET f_quarantine = '[Quarantined UserId' & if(tipo='user',']',' $(tipo)]');\r\n    LET tipo_lower = lower(tipo);\r\n\r\n    LIB CONNECT TO 'monitor_apps_REST_license_$(tipo_lower)';\r\n\ttrace connect to monitor_apps_REST_license_$(tipo_lower);\r\n\r\n    user_map:\r\n    Mapping LOAD\r\n\t[__FK_user]&'$(tipo_lower)' as key,\r\n\tLOWER(userDirectory & '\\' & userId) as UserId   \r\n    ;\r\n    SQL SELECT \r\n        (SELECT \r\n            \"id\",\r\n            \"userId\",\r\n            \"userDirectory\",\r\n            \"__FK_user\"\r\n        FROM \"user\" FK \"__FK_user\")\r\n    FROM JSON (wrap on) \"root\" PK \"__KEY_root\" ;\r\n\r\n    //License_$(tipo)Access:\r\n    Concatenate (License_User_Access_Types)\r\n    LOAD\r\n      *,\r\n      if(ualu > $(minSenseActivityDate),null(), UserId) as [Unused but Allocated UserId],\t// Populate this only with UserIds of allocated but unused user access passes\r\n      if(ualu > $(minSenseActivityDate), ualu,'Never') as [User Access Last Used],\r\n      if(lower([User Access Quarantined])='true',UserId) as [Quarantined UserId],\r\n      if(uaqe > $(minSenseActivityDate),uaqe,null()) as [User Access Quarantine End]\r\n    ;\r\n    LOAD\t\r\n      date(\r\n        alt(\r\n          date#(left(createdDate,10),'YYYY-MM-DD'),\r\n          date#(left(createdDate,10),'YYYY/MM/DD'),\r\n          date#(left(createdDate,10),'MM-DD-YYYY'),\r\n          date#(left(createdDate,10),'MM/DD/YYYY'),\r\n          date#(left(createdDate,10),'YYYY.MM.DD'),\r\n          'No valid date')\r\n          ) as [User Access Created],\r\n      date(\r\n        alt(\r\n          date#(left(modifiedDate,10),'YYYY-MM-DD'),\r\n          date#(left(modifiedDate,10),'YYYY/MM/DD'),\r\n          date#(left(modifiedDate,10),'MM-DD-YYYY'),\r\n          date#(left(modifiedDate,10),'MM/DD/YYYY'),\r\n          date#(left(modifiedDate,10),'YYYY.MM.DD'),\r\n          'No valid date')\r\n          ) as [User Access Modified],\r\n      [modifiedByUserName] as [User Access Modified by],\r\n      date(\r\n        alt(\r\n          date#(left(lastUsed,10),'YYYY-MM-DD'),\r\n          date#(left(lastUsed,10),'YYYY/MM/DD'),\r\n          date#(left(lastUsed,10),'MM-DD-YYYY'),\r\n          date#(left(lastUsed,10),'MM/DD/YYYY'),\r\n          date#(left(lastUsed,10),'YYYY.MM.DD'),\r\n          'No valid date')\r\n          ) as ualu,\r\n\r\n       if(quarantined='True',\r\n        date(\r\n          alt(\r\n            date#(left(quarantineEnd,10),'YYYY-MM-DD'),\r\n            date#(left(quarantineEnd,10),'YYYY/MM/DD'),\r\n            date#(left(quarantineEnd,10),'MM-DD-YYYY'),\r\n            date#(left(quarantineEnd,10),'MM/DD/YYYY'),\r\n            date#(left(quarantineEnd,10),'YYYY.MM.DD'),\r\n            'No valid date')\r\n              )) as uaqe,\r\n        quarantined as [User Access Quarantined],\r\n        1 as [User Access Token Count],\r\n        '$(tipo)' as [Allocated Access Type],\r\n        applymap('user_map',__KEY_root&'$(tipo_lower)','Unknown') as UserId\t\t// Link to LogContent > userDirectory\\userId\r\n    ;\r\n    SQL SELECT \r\n      \"id\",\r\n      \"createdDate\",\r\n      \"modifiedDate\",\r\n      \"modifiedByUserName\",\r\n      \"lastUsed\",\r\n      \"quarantined\",\r\n      \"quarantineEnd\",\r\n      \"__KEY_root\"\r\n    FROM JSON (wrap on) \"root\" PK \"__KEY_root\" ;//QDL;    \r\n\r\n    LET NumRows_monitor_apps_REST_license_$(tipo) = NoOfRows('License_User_Access_Types');\r\n    \r\n    DROP FIELDs uaqe, ualu;\r\n    DisConnect;\r\n    \r\n  Next tipo\r\n\r\n  LET NumRows_monitor_apps_REST_license_user = NoOfRows('License_User_Access_Types');\r\n\r\nENDSUB\r\n\r\n///$tab license_login\r\nSUB monitor_apps_REST_license_login\r\n  \r\n  LIB CONNECT TO 'monitor_apps_REST_license_login';\r\n  \r\n  License_LoginAccessGroups:\r\n  Load\r\n      timestamp(\"createdDate\",'YYYY-MM-DD hh:mm') as [Login Access Created],\r\n      timestamp(\"modifiedDate\",'YYYY-MM-DD hh:mm') as [Login Access Modified],\r\n      \"modifiedByUserName\" as [Login Access Modified by],\r\n      \"name\" as [Login Access Rule],\r\n      \"usedAccessTypes\" as [Login Passes Used],\r\n      \"remainingAccessTypes\" as [Login Passes Remaining],\t// ??\r\n      \"assignedAccessTypes\" as [Login Passes Assigned],\t// ??\r\n      \"assignedTokens\" as [Login Access Token Count];\r\n  SQL SELECT \r\n      \"createdDate\",\r\n      \"modifiedDate\",\r\n      \"modifiedByUserName\",\r\n      \"name\",\r\n      \"usedAccessTypes\",\r\n      \"remainingAccessTypes\",\r\n      \"assignedAccessTypes\",\r\n      \"assignedTokens\"\r\n      \r\n  FROM JSON (wrap on) \"root\";\r\n  \r\n  LET NumRows_monitor_apps_REST_license_login = NoOfRows('License_LoginAccessGroups');\r\n  \r\nENDSUB\r\n\r\n///$tab user\r\nSUB monitor_apps_REST_user\r\n\r\nLIB CONNECT TO 'monitor_apps_REST_user_condensed';  \r\n\r\nUser:\r\n  Load\r\n   LOWER(userDirectory & '\\' & userId) AS UserId,\r\n   [name] AS [User Name],\r\n   userDirectory as [User Directory]\r\n  ;\r\n  SQL SELECT \r\n      \"userId\",\r\n      \"userDirectory\",\r\n      \"name\"\r\n  FROM JSON (wrap on) \"root\"; \r\n\r\nENDSUB\r\n///$tab license_access\r\nSUB monitor_apps_REST_license_access\r\n\r\n  LIB CONNECT TO 'monitor_apps_REST_license_overview';\r\n\r\n  RestConnectorMasterTable:\r\n  SQL SELECT \r\n      \"totalTokens\",\r\n      \"availableTokens\",\r\n      \"tokensEnabled\",\r\n      \"__KEY_root\",\r\n      (SELECT \r\n          \"enabled\" AS \"enabled_user\",\r\n          \"tokenCost\" AS \"tokenCost_user\",\r\n          \"allocatedTokens\" AS \"allocatedTokens_user\",\r\n          \"usedTokens\" AS \"usedTokens_user\",\r\n          \"quarantinedTokens\" AS \"quarantinedTokens_user\",\r\n          \"__FK_userAccess\"\r\n      FROM \"userAccess\" FK \"__FK_userAccess\"),\r\n      (SELECT \r\n          \"enabled\" AS \"enabled_login\",\r\n          \"tokenCost\" AS \"tokenCost_login\",\r\n          \"allocatedTokens\" AS \"allocatedTokens_login\",\r\n          \"usedTokens\" AS \"usedTokens_login\",\r\n          \"unavailableTokens\" AS \"unavailableTokens_login\",\r\n          \"__FK_loginAccess\"\r\n      FROM \"loginAccess\" FK \"__FK_loginAccess\"),\r\n      (SELECT \r\n          \"enabled\" AS \"enabled_professional\",\r\n          \"total\" AS \"total_professional\",\r\n          \"allocated\" AS \"allocated_professional\",\r\n          \"used\" AS \"used_professional\",\r\n          \"quarantined\" AS \"quarantined_professional\",\r\n          \"available\" AS \"available_professional\",\r\n          \"__FK_professionalAccess\"\r\n      FROM \"professionalAccess\" FK \"__FK_professionalAccess\"),\r\n      (SELECT \r\n          \"enabled\" AS \"enabled_analyzer\",\r\n          \"total\" AS \"total_analyzer\",\r\n          \"allocated\" AS \"allocated_analyzer\",\r\n          \"used\" AS \"used_analyzer\",\r\n          \"quarantined\" AS \"quarantined_analyzer\",\r\n          \"available\" AS \"available_analyzer\",\r\n          \"__FK_analyzerAccess\"\r\n      FROM \"analyzerAccess\" FK \"__FK_analyzerAccess\"),\r\n\t(SELECT \r\n\t\t\"enabled\" AS \"enabled_analyzer_capacity\",\r\n\t\t\"allocatedMinutes\" as \"allocated_analyzer_capacity_minutes\",\r\n\t\t\"usedMinutes\" as \"used_analyzer_capacity_minutes\",\r\n\t\t\"unavailableMinutes\" as \"unavailable_analyzer_capacity_minutes\",\r\n\t\t\"__FK_analyzerTimeAccess\"\r\n\tFROM \"analyzerTimeAccess\" FK \"__FK_analyzerTimeAccess\")\r\n  FROM JSON (wrap on) \"root\" PK \"__KEY_root\";\r\n\r\n  LET NumRows_monitor_apps_REST_license_access = NoOfRows('RestConnectorMasterTable');\r\n\r\n  License_Summary:\r\n  LOAD\r\n    [totalTokens] AS [License Total Tokens],\r\n    [availableTokens] AS [License Total Available Tokens],\r\n    IF(upper([tokensEnabled])='FALSE',Dual('User-based',1),Dual('Token-based',0)) AS [License Type Enabled]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__KEY_root]);\r\n  \r\n  Let license_type_enabled = Peek('License Type Enabled');\r\n  TRACE $(license_type_enabled) license type enabled;\r\n\r\n  //loginAccess:\r\n  Concatenate (License_Summary) LOAD\r\n    [enabled_login] AS [License Access Enabled],\r\n    'Login Access' as [License Token Type],\r\n    [tokenCost_login] AS [License Token Cost],\r\n    [allocatedTokens_login] AS [License Allocated Tokens],\r\n    [usedTokens_login] AS [License Used Tokens],\r\n    [unavailableTokens_login] AS [License Unavailable Tokens]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__FK_loginAccess]) AND NOT UPPER([enabled_login])='FALSE';\r\n\r\n  //userAccess:\r\n  Concatenate (License_Summary) LOAD\r\n    [enabled_user] AS [License Access Enabled],\r\n    'User Access' as [License Token Type],\r\n    [tokenCost_user] AS [License Token Cost],\r\n    [allocatedTokens_user] AS [License Allocated Tokens],\r\n    [usedTokens_user] AS [License Used Tokens],\r\n    [quarantinedTokens_user] AS [License Quarantined Tokens]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__FK_userAccess]) AND NOT UPPER([enabled_user])='FALSE';\r\n\r\n  //professionalAccess:\r\n  Concatenate (License_Summary) LOAD\r\n\t[enabled_professional] AS [License Access Enabled],\r\n    'Professional Access' as [License Token Type],\r\n    [total_professional] AS [License Total Tokens],\r\n    [allocated_professional] AS [License Allocated Tokens],\r\n    [used_professional] AS [License Used Tokens],\r\n    [quarantined_professional] AS [License Quarantined Tokens],\r\n    [available_professional] AS [License Total Available Tokens]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__FK_professionalAccess]) AND NOT UPPER([enabled_professional])='FALSE';\r\n  \r\n  //analyzerAccess:\r\n  Concatenate (License_Summary) LOAD\r\n\t[enabled_analyzer] AS [License Access Enabled],\r\n    'Analyzer Access' as [License Token Type],\r\n    [total_analyzer] AS [License Total Tokens],\r\n    [allocated_analyzer] AS [License Allocated Tokens],\r\n    [used_analyzer] AS [License Used Tokens],\r\n    [quarantined_analyzer] AS [License Quarantined Tokens],\r\n    [available_analyzer] AS [License Total Available Tokens]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__FK_analyzerAccess]) AND NOT UPPER([enabled_analyzer])='FALSE';\r\n  \r\n    // analyzerTimeAccess:\t== Analyzer Capacity\r\n  Concatenate (License_Summary) LOAD\r\n\t[enabled_analyzer_capacity] AS [License Access Enabled],\r\n    'Analyzer Capacity' as [License Token Type],\r\n    [allocated_analyzer_capacity_minutes] AS [License Allocated Analyzer Capacity (Minutes)],\r\n    [used_analyzer_capacity_minutes] AS [License Used Analyzer Capacity (Minutes)],\r\n    [unavailable_analyzer_capacity_minutes] AS [License Unavailable Analyzer Capacity (Minutes)]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__FK_analyzerTimeAccess]) AND NOT UPPER([enabled_analyzer_capacity])='FALSE';\r\n\r\n  DROP TABLE RestConnectorMasterTable;\r\n  \r\nENDSUB\r\n///$tab license\r\nSUB monitor_apps_REST_license\r\n\r\n   Set errormode = 0;\t// TODO -- temporary until Repo update\r\n  LIB CONNECT TO 'monitor_apps_REST_license';\r\n\r\n  License:\r\n  Load *,\r\n  \t[License Message] & '. ' & Subfield([License Details],', Expired',1) as [License Message + Details] \r\n  ;\r\n  Load\r\n  \tserial as [License Serial Number],\r\n    name & ': ' & organization as [License Name & Organization],\r\n    if(len(key)>1,'Signed License',lef) as [License LEF],\r\n    Date(createdDate) as [License Created Date],\r\n    Date(modifiedDate) as [License Modified Date],\r\n    serial & ' for ' & name & ': ' & organization \r\n    \t& ' created ' & Date(createdDate) \r\n        & ' and last modified ' & Date(modifiedDate) & ' by ' & modifiedByUserName\r\n    \t\t\tAS [License Message],\r\n    'Site License created ' & Date(createdDate) \r\n        & ', last modified ' & Date(modifiedDate) & ' by ' & modifiedByUserName\r\n    \t\t\tAS [License Created & Modified Message],\r\n    'Subscription: ' & isSubscription \r\n        & ', Product: ' & product & ', Cores: ' & numberOfCores\r\n    \t& ', Elastic: ' & isElastic & ', CloudServices: ' & isCloudServices\r\n        & ', Expired: ' & isExpired & If(isExpired,'('&expiredReason & ')')\r\n        & ', Invalid: ' & isInvalid & ', Blacklisted: ' & isBlacklisted\r\n        \t\tAS [License Details]  \r\n  ;\r\n  SQL SELECT \r\n      \"createdDate\",\r\n      \"modifiedDate\",\r\n      \"modifiedByUserName\",\r\n      \"lef\",\r\n      \"serial\",\r\n      \"key\",\r\n      \"name\",\r\n      \"organization\",\r\n      \"product\",\r\n      \"numberOfCores\",\r\n      \"isExpired\",\r\n      \"expiredReason\",\r\n      \"isBlacklisted\",\r\n      \"isInvalid\",\r\n      \"isSubscription\",\r\n      \"isCloudServices\",\r\n      \"isElastic\"\r\n  FROM JSON (wrap on) \"root\";\r\n\r\n  LET license_message \t= If(IsNull(Peek('License Message')),'License Details not available',Peek('License Message'));\r\n  LET license_details \t= If(IsNull(Peek('License Details')),'License Details not available',Peek('License Details'));\r\n  LET license_created_modified \t= If(IsNull(Peek('License Created & Modified Message')),'License Details not available',Peek('License Created & Modified Message'));\r\n  LET license_lef \t\t= If(IsNull(Peek('License LEF')),'License Details not available',Peek('License LEF'));\r\n  LET license_number \t= If(IsNull(Peek('License Serial Number')),'Not available',Peek('License Serial Number'));\r\n  TRACE License Details: $(license_details);\r\n  LET NumRows_monitor_apps_REST_license = NoOfRows('License');\r\n\r\n  Set errormode = 1;\t// TODO -- temporary\r\n\r\nENDSUB\r\n///$tab app\r\nSUB monitor_apps_REST_app\r\n\r\n  //  1 Get App Id (ID) and Stream name from app & stream endpoints\r\n  LIB CONNECT TO 'monitor_apps_REST_app';\r\n  \r\n  RestConnectorMasterTable:\r\n  SQL SELECT \r\n      \"id\" AS \"id_u1\",\r\n      \"__KEY_root\",\r\n      (SELECT \r\n          \"id\" AS \"id_u0\",\r\n          \"name\" AS \"name_u0\",\r\n          \"__FK_stream\"\r\n      FROM \"stream\" FK \"__FK_stream\")\r\n  FROM JSON (wrap on) \"root\" PK \"__KEY_root\";\r\n  \r\n  LET NumRows_monitor_apps_REST_app = NoOfRows('RestConnectorMasterTable');\r\n  \r\n  mapStream:\r\n  MAPPING LOAD\r\n      [__FK_stream],\r\n      [name_u0] as streamName\t\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__FK_stream]);\r\n  \r\n  App:\r\n  LOAD\t[id_u1] AS AppId,\r\n      ApplyMap('mapStream',__KEY_root,'Unpublished') as [App Stream]\r\n  RESIDENT RestConnectorMasterTable\r\n  WHERE NOT IsNull([__KEY_root]);\r\n  \r\n  DROP TABLE RestConnectorMasterTable;\r\n\r\nENDSUB\r\n///$tab qlikview_logs\r\nSUB qlikview_logs\r\n\r\n  TRACE Checking for presence of QlikView Server logs (for dual-use QV and Sense customers).;\r\n  SET qlikview_license_logs_present = 0;\t// Reset this each time\r\n  \r\n  // Set some variables then check for Sessions and events QVDs\r\n  for each log in 'Sessions','Events'\r\n    Let qv_$(log)_qvd_file_name = '$(serverLogFolder)governance_qlikview_$(log)_$(app_version)';\r\n    Set rows_$(log)_incremental = 0;\r\n    SET rows_$(log)_final\t\t= 0;\r\n    \r\n    CALL loadBaseTable ('qlikview_$(log)_historical', '$(qv_$(log)_qvd_file_name)')\r\n    If NoOfRowsqlikview_$(log)_historicalBASE > 0 Then \t// Check historical QVD data fetched?\r\n      TRACE Found QlikView $(log) historical QVD with $(NoOfRowsqlikview_$(log)_historicalBASE) rows fetched;\r\n    ELSE\r\n      TRACE No QlikView $(log) logs historical QVD found (stay calm).;\r\n    ENDIF\r\n    \r\n    LET qlikview_log_cutoff\t\t\t= lastReloadCompare;\t\t// Align this\r\n    LET qlivkiew_log_cutoff_pretty\t= Timestamp(lastReloadCompare);\r\n    \r\n    // Start a table to which we will concatenate log file data if they exist\r\n    qlikview_$(log):\r\n    NoConcatenate Load * Inline [SessionId];\r\n    \r\n    // For Session log, create mapping table of user -- temporary table that disappears post reload\r\n    If log = 'Sessions' Then\r\n      map_user:\r\n      Mapping Load Distinct UserId, [User Name] Resident User;\r\n      \r\n    ENDIF\r\n    \r\n    // Allow looping through multiple qlikview_logs data connections in case customer wants to add usage data from multiple QlikView deployments.\r\n    Set errormode = 0;\t\t// Disable task failure on error because old QlikView Server logs might not include SessionId\r\n    For each data_connection in 'monitor_apps_qlikview_logs'\r\n    // Find each \"log\" file and fetch it, taking notie of the qlikview_log_cutoff\r\n      For Each log_file in FileList('lib://$(data_connection)/$(log)_*.log')\r\n        If FileTime('$(log_file)') >= qlikview_log_cutoff Then\r\n        \r\n          IF '$(log)' = 'Sessions' Then\r\n            Concatenate (qlikview_$(log))\r\n            Load\r\n            \tSessionId,\r\n               '$(log)' & SessionId & \"Timestamp\" as _session_id_timestamp,\t// field for concatenation\r\n               '$(log)' & SessionId & \"Timestamp\" as _concat_temp,\t\t\t// temp field for concatenation\r\n                Timestamp(\"Timestamp\") as LogTimeStamp,\r\n                Timestamp(\"Session Start\") as LogEntryPeriodStart,\r\n                Date(Floor(\"Timestamp\")) as [Access Date],\r\n                \"Cal Type\" as [Access Type],                \r\n                TextBetween('$(log_file)','sions_','_20') as Hostname,\r\n                (round(num(\"Session Start\"),0.0006)&'|'&round(num(\"Timestamp\"),0.0006)) as _TimeDIM_Link,\r\n                [Exe Version],\r\n                LOWER(\"Authenticated user\") as [UserId],\r\n                SubField(\"Authenticated user\",'\\',1) as [User Directory],\r\n                ApplyMap('map_user',LOWER(\"Authenticated user\"),SubField(LOWER(\"Authenticated user\"),'\\',-1)) as [User Name],\t// Attempt to get User Name from QRS table, but might not exist here in Sense (from QlikView)\r\n                SubField(SubField(Document,'/',-1),'.qvw',1) as [App Name],\t// Using SubField to capture just the file name without the entire path. \r\n//                 Document as [App Name],\t\t\t\t\t\t\t\t\t// NOTE: If the same named app exists in multiple Source Doc folders, use this [App Name] (uncomment this line) and comment the [App Name] in the previous line. \r\n                Hash128(Document & \"Document Timestamp\") as [AppId],\t\t// Since we do not have true AppId from QlikView logs\r\n                SessionId & Session & Document as proxy_session_id_app_id,\r\n                'QlikView' as [App Stream]\r\n            FROM '$(log_file)' (txt, utf8, embedded labels, delimiter is '\\t', msq)\r\n            WHERE \"Timestamp\" > '$(qlikview_log_cutoff)'\r\n            \tAND WildMatch(\"Cal Type\",'Professional*','Analyzer*') > 0\t// We only want Analyzer, Professional, and Analyzer Capacity session data\r\n            ;\r\n          \r\n          ELSEIF '$(log)' = 'Events' Then\r\n            Concatenate (qlikview_$(log))\r\n            Load\r\n            \tSessionId,\r\n                '$(log)' & SessionId & \"Timestamp\" as _session_id_timestamp,\r\n                '$(log)' & SessionId & \"Timestamp\" as _concat_temp,\t\t\t// temp field for concatenation\r\n                Timestamp(\"Timestamp\") as LogTimeStamp,\r\n                'Analyzer Capacity' as [Access Type],\r\n                Message\r\n            FROM '$(log_file)' (txt, utf8, embedded labels, delimiter is '\\t', msq)\r\n            WHERE \"Timestamp\" > '$(qlikview_log_cutoff)'\r\n            \tAND WildMatch(Message,'*Analyzer Capacity*')=1;          \r\n          \r\n          ELSE\r\n          \tTRACE Problem resolving \"log\" variable in loop in qlikview_logs subroutine. Contact support.;\r\n          ENDIF\r\n        \r\n        ELSE\r\n          TRACE $(log_file) older than cutoff date $(qlikview_log_cutoff_pretty);\r\n        ENDIF\r\n\r\n      Next log_file\r\n    Next data_connection\r\n    Set errormode = 1;\t// Enable error failure again\r\n    \r\n    Let rows_$(log)_incremental = NoOfRows('qlikview_$(log)');\r\n    \r\n    // If there are no QlikView Session log entries (incremental or historical) then we exit out of here because we either do not have data or the monitor_apps_qlikview_logs data connection was not properly set\r\n    //\t\tThis will be the more common scenario because only dual-use (QV + Qlik Sense) customers will configure things in this manner\r\n    IF rows_Sessions_incremental +  NoOfRowsqlikview_Sessions_historicalBASE = 0 Then\r\n      TRACE No QlikView Server logs found. Skipping remaining qlikview log logic. No worries. This is expected behavior unless you are a dual-use customer and have configured the monitor_apps_qlikview_logs data connection.;\r\n      Drop table qlikview_$(log), qlikview_$(log)_historical;\r\n      Exit Sub;\r\n    ENDIF\r\n    \r\n    // Concatenate and Store table as needed\r\n    If rows_$(log)_incremental > 0 Then\r\n    \r\n      If NoOfRowsqlikview_$(log)_historicalBASE > 0 Then\r\n        // Concatenate\r\n        Concatenate (qlikview_$(log))\r\n        Load * Resident qlikview_$(log)_historical\r\n        Where not Exists (_concat_temp,_session_id_timestamp);\t\t// Avoid loading session / audit entries from historical QVD that we already loaded incrementally\r\n              \r\n      ELSE\r\n        TRACE No Historical QVD found for $(log) -- so saving the incremental $(log) logs to QVD for next reload.;\r\n      ENDIF\r\n      \r\n      Let f_name = '$(qv_$(log)_qvd_file_name)';\r\n      Drop field _concat_temp;\t// Drop concatenation-only field(s \r\n      CALL storeFiles ('qlikview_$(log)','$(f_name)')\r\n      Drop Table qlikview_$(log)_historical;\r\n      \r\n    ELSE\t// No incremental logs\r\n      TRACE No Incremental QlikView $(log) log entries found (Expected for all but Unified Licensing customers using QlikView). If you believe you should have incremental entries, please verify the monitor_apps_qlikview_logs data connection and that there are logs newer than $(qlivkiew_log_cutoff_pretty).;\r\n      Drop Table qlikview_$(log);\r\n      \r\n      If NoOfRowsqlikview_$(log)_historicalBASE > 0 Then\t// Historical QVD has data but no incremental logs\r\n      \tRename Table qlikview_$(log)_historical to qlikview_$(log);\r\n      ELSE\t// No historical QVD or incremental logs. This should only ever happen for Events logs when you are not using Analyzer Capacity minutes\r\n      \tDrop Table qlikview_$(log)_historical;\r\n      ENDIF\r\n      \r\n    ENDIF\t// incremental logs check\r\n    \r\n    Let rows_$(log)_final = NoOfRows('qlikview_$(log)');\r\n    \r\n  next log\r\n  \r\n  // Aggregate and join Analyzer Capacity log entries (from QlikView Events log) to Sessions to get correct consumption of Analyzer Capacity minutes\r\n  If rows_Events_final > 0 Then\r\n    TRACE Aggregating Analyzer Capacity usage (from QlikView Events log);\r\n    \r\n    aggregated_events_analyzer_capacity:\r\n    Load\r\n      SessionId,\r\n      Count(SessionId) as [Analyzer Capacity Used (Units)],\r\n      Count(SessionId)*$(va_analyzer_capacity_consumption_minutes) as [Analyzer Capacity Used (Minutes)]\r\n    Resident qlikview_Events\r\n    Group By SessionId;\r\n    \r\n    \r\n    Join (qlikview_Sessions)\r\n    Load \r\n      SessionId,  \r\n      [Analyzer Capacity Used (Units)],  \r\n      [Analyzer Capacity Used (Units)]*$(va_analyzer_capacity_consumption_minutes) as [Analyzer Capacity Used (Minutes)] \r\n    Resident aggregated_events_analyzer_capacity;\r\n    \r\n    Drop table aggregated_events_analyzer_capacity;\r\n   \r\n  ELSE\t// No QlikView Event log entries for Analyzer Capacity usage found\r\n    TRACE  No QlikView Event log entries for Analyzer Capacity usage found. Not a problem unless you have been using Analyzer Capacity (minutes) in QlikView.;\r\n    // For consistency when appending this data below to LogContent, we need to have Analyzer Capcity fields\r\n    Concatenate (qlikview_Sessions) load * Inline [ SessionId, Analyzer Capacity Used (Minutes), Analyzer Capacity Used (Units)];\r\n  ENDIF      \r\n  \r\n  Drop Table qlikview_Events;\t// No longer need this table\r\n  \r\n  IF rows_Sessions_final > 0 Then\r\n  \r\n\t  TRACE Appending QlikView Session (license consumption) data to existing tables so that it becomes part of the happy License Monitor Data Model;\r\n\t  Concatenate (LogContent)\r\n\t  Load\r\n\t\tSessionId as ProxySessionId,\r\n\t//     [Exe Version] as [QlikView Exe Version],\r\n\t\tUserId,\r\n\t\tLogEntryPeriodStart,\r\n\t\tLogTimeStamp,\r\n\t\t[_TimeDIM_Link],\t\t// this should get incorporated into the master calendar with the other log data\r\n\t\tHostname,\r\n\t\t[Access Type],\r\n\t\t[Access Date],\r\n\t\t[Analyzer Capacity Used (Minutes)],\r\n\t\t[Analyzer Capacity Used (Units)],\r\n\t\t'QlikView' as [Unified Licensing Product]\r\n\t  Resident qlikview_Sessions;\r\n\t  \r\n\t  Concatenate (User)\r\n\t  Load\r\n\t\tDistinct UserId,\r\n\t\t[User Name],\r\n\t\t[User Directory]\r\n\t  Resident qlikview_Sessions;\r\n\t  \r\n\t  Concatenate (sessionData)\r\n\t  Load\r\n\t\tSessionId as ProxySessionId,\r\n\t\tAppId,\r\n\t\t[App Name],\r\n\t\tproxy_session_id_app_id\r\n\t  Resident qlikview_Sessions;\r\n\t  \r\n\t  Concatenate (App)\r\n\t  Load\r\n\t\tDistinct AppId,\r\n\t\t[App Stream]\r\n\t  Resident qlikview_Sessions;\r\n\t  \r\n\t  // Get max Exe Version from QlikView Session log\r\n\t  max_exe_version:\r\n\t  Load \r\n\t\tMaxString([Exe Version]) as maxstring_exe_version\r\n\t  Resident qlikview_Sessions;\r\n\t  \r\n\t  Let qlikview_maxstring_exe_version = Peek('maxstring_exe_version');\r\n\t  TRACE QlikView Exe version (maxString) = $(qlikview_maxstring_exe_version);\r\n\t  \r\n\t  Drop tables qlikview_Sessions, max_exe_version;\t// No longer need this table\r\n\t  \r\n\t  TRACE Celebrate! This script has included QlikView Professional and Analyzer Usage data in the License Monitor. Woohoo!;\r\n\t  SET qlikview_license_logs_present = 1;\t\t// This is used in the UI of the app to hide/show metrics (see supportingLogic) and provide different messaging\r\n\r\n\tELSE\r\n\t  TRACE No QlikView Server logs found (which is expected for all non-Unified Licensing QlikView and Sense customers).;\r\n\t  Drop Table qlikview_Sessions;\r\n\tENDIF\r\n\t  \r\nENDSUB\r\n///$tab calendarization\r\nSUB calendarization\r\n  \r\n// Work out the first and last date from my data\r\n  Range:\r\n  LOAD \r\n    DayStart(min) as startdate,\r\n    DayStart(max) as enddate,\r\n    timestamp(max) as maxLogTimeStamp;\r\n  LOAD    \r\n     min(LogEntryPeriodStart) as min,\r\n     max(LogTimeStamp) as max\r\n  resident LogContent;\r\n\r\n  IF Not NoOfRows('Range')> 0 THEN\r\n  // If no LogContent messages found, script would fail. Need to verify data connections - most likely issue with ArchivedLogsFolder QLIK-88005\r\n      set msg = 'ERROR: No license usage data found. Reload aborted.\r\n\tPlease verify that the following data connections are correct: ArchivedLogsFolder, ServerLogFolder.';\r\n      CALL monitor_app_reload_stats('ERROR','License Monitor',msg,'Reload Finish');\r\n      TRACE $(msg);\r\n      Exit Script;\r\n  ENDIF\r\n\r\n  let startdate= num(peek('startdate',-1,'Range'),'###0.#####','.');\r\n  let enddate= num(num(peek('enddate',-1,'Range')) +1,'###0.#####','.') ;\r\n  let maxLogTimeStamp = peek('maxLogTimeStamp',-1,'Range');\r\n  Let maxLogTimeStamp_Hour = hour(maxLogTimeStamp);\r\n\r\n// Build a table of every minute between my start and end date\r\n    drop table Range;\r\n\r\n    do while startdate <= enddate\r\n          tempDateTimeList:\r\n          load\r\n               timestamp($(startdate) + (1/(24*60))*(recno()-1),'YYYY-MM-DD h:mm') as DateTime\r\n          autogenerate (24*60);\r\n\r\n          let startdate = num($(startdate) + 1,'###0.#####','.') ;\r\n    loop \r\n\r\n  // To create hour sort order which sorts backward from now(reload) -- for 24-Hour summary charts\r\n  Let hour_now = maxLogTimeStamp_Hour;\r\n  hour_temp:\r\n  mapping Load \r\n     recno()-1 & ':00' as Hour,\r\n     if($(hour_now)-(recno()-1)>=0, $(hour_now)-(recno()-1),23+($(hour_now)-(recno()-1))+1) as hour_sort\r\n  autogenerate (24);\r\n\r\n\r\n//Build time table\r\n  TimeDIM:\r\n  LOAD\r\n    DISTINCT DateTime,\r\n    Year(DateTime) as Year,\r\n    MonthName(DateTime) as Month,\t\t// replace with date(DateTime, 'MMM YYYY') for better performance\r\n    WeekStart(DateTime) as [Week Beginning],\r\n    date(dayname(DateTime),'MMM-DD') as Day,\r\n    WeekDay(DateTime) as Weekday,\r\n    makedate(year(DateTime),month(DateTime),day(DateTime)) as Date,  \r\n    Hour(DateTime)&':00' as Hour,\r\n    ApplyMap('hour_temp',Hour(DateTime)&':00' ) as hour_sort,\r\n    Minute(DateTime) as [Minute of Hour],\r\n    timestamp(floor(DateTime,1/(24)),'MMM-DD hh:00') as [Hour Timeline],\r\n    -1*InMonthToDate(DateTime,today(1),0)\t\t\t\t\tAS month_to_date,\r\n    -1*InMonth(DateTime,today(1),-1)\t\t\t\t\t\tAS last_month,\r\n    If(DateTime>=$(vLast7Days),1) \t\t\t\t\t\t\tAS last7days,\r\n    If(DateTime>=$(vLast14Days),1) \t\t\t\t\t\t\tAS last14days,\r\n    If(DateTime>=$(vLast28Days),1) \t\t\t\t\t\t\tAS last28days,\r\n    If(DateTime>=$(vLast90Days),1) \t\t\t\t\t\t\tAS last90days\r\n  resident tempDateTimeList;\r\n\r\n  Drop table tempDateTimeList;  \r\n\r\n  Last:\r\n  Load Distinct [Hour Timeline], 'Last 7 Days' as [Timeframe] Resident TimeDIM Where last7days=1;\r\n  Concatenate Load [Hour Timeline], 'Last 14 Days' as [Timeframe] Resident TimeDIM Where last14days=1;\r\n  Concatenate Load [Hour Timeline], 'Last 28 Days' as [Timeframe] Resident TimeDIM Where last28days=1;\r\n  Concatenate Load [Hour Timeline], 'Last 90 Days' as [Timeframe] Resident TimeDIM Where last90days=1;\r\n\r\n//Interval Match dates\r\n  inner join (TimeDIM) Intervalmatch (DateTime) Load LogEntryPeriodStart-(1/(24*60)) AS start_minus_one, LogTimeStamp Resident LogContent;\r\n\r\n  datetime:\r\n  NoConcatenate\r\n  Load\r\n   hour_sort, DateTime,Year, Month,[Week Beginning], Day, Weekday, Date, Hour,[Minute of Hour],[Hour Timeline],last28days,month_to_date,last_month,\r\n   (round(num(start_minus_one+1/(24*60)),0.0006)&'|'&round(num(LogTimeStamp),0.0006)) as _TimeDIM_Link\t// LINK w/ LogContent\r\n  RESIDENT TimeDIM\r\n  order by DateTime DESC;\r\n\r\n  drop table TimeDIM;\r\n\r\n// For all non-24-hour Summary charts, we want \"normal\" numeric sorting of Hour from 0 to 23 hours\r\n  Hour_Table:\r\n  NoConcatenate\r\n  Load\r\n      rowno()-1 & ':00' as Hour,\r\n      rowno()-1 & ':00' as [Hour of Day]\r\n  AutoGenerate (24);\r\n\r\n  Minute_Table:\r\n  NoConcatenate\r\n  Load\r\n      rowno()-1 as [Minute of Hour],\t\t// Link Field\r\n      rowno()-1 as Minute       \t\t\t// Field for filter, dimension, etc.\r\n  AutoGenerate (60);\t\r\n\r\nENDSUB\r\n\r\n///$tab supportingLogic\r\nSUB supportingLogic\r\n\r\n  //// Dimension table to support Dashboard \"Excel\" chart\r\n \r\n  IF license_type_enabled = 'User-based' THEN\r\n    \r\n    If qlikview_license_logs_present = 1 THEN\r\n  \t// QlikView logs loaded, which means Sense is also licensing with user-based Analyzer, Professional\r\n    // Add a few more metrics\r\n      dim_dash:\r\n      LOAD * INLINE\r\n      [\r\n        dimNum, dimName\r\n        1, Total Users\r\n        2, First-time Users\r\n        3, Sense Professional Users\r\n        3.1, QlikView Professional Users\r\n        4, Sense Analyzer Users\r\n        4.1, QlikView Analyzer Users\r\n        4.5, Sense Analyzer Capacity Users    \r\n        4.8, QlikView Analyzer Capacity Users        \r\n        5, Avg Daily Users\r\n        6, Max Daily Users\r\n        7, Access Denials      \r\n        8, Allocation Changes\r\n      ];\r\n      \r\n    ELSE \r\n    \r\n      dim_dash:\r\n      LOAD * INLINE\r\n      [\r\n          dimNum, dimName\r\n          1, Total Users\r\n          2, First-time Users\r\n          3, Professional Users\r\n          4, Analyzer Users\r\n          4.5, Analyzer Capacity Users\r\n          5, Avg Daily Users\r\n          6, Max Daily Users\r\n          7, Access Denials      \r\n          8, Allocation Changes\r\n      ];\r\n    ENDIF\r\n    \r\n    // Messaging for Analyzer Capacity Time usage\r\n    For each vs_analyzer_capacity_var in 'Allocated','Used','Unavailable'\r\n      Let vs_analyzer_capacity_$(vs_analyzer_capacity_var) = Num(Peek('License $(vs_analyzer_capacity_var) Analyzer Capacity (Minutes)',-1,'License_Summary'),'#,##0');\r\n    Next vs_analyzer_capacity_var \r\n    \r\n    IF vs_analyzer_capacity_Allocated >5 Then\r\n    \tLet vs_analyzer_capacity_per_day = Ceil($(#vs_analyzer_capacity_Used)/(today(1)-MonthStart(Today(1))+1));\r\n        \r\n        // QB-3498: Added IsNull check. \r\n        Let vs_analyzer_capacity_run_out_days = if(\tIsNull( vs_analyzer_capacity_per_day ),0, If(vs_analyzer_capacity_per_day = 0,99, Floor( vs_analyzer_capacity_Allocated/vs_analyzer_capacity_per_day)));\r\n        \r\n    \tLet va_analyzer_capacity_message = 'Analyzer Capacity Minutes:  To date in '& MonthName(Today(1)) & ' you have used $(vs_analyzer_capacity_Used) of $(vs_analyzer_capacity_Allocated) total minutes'\r\n        \t\t\t\t\t\t\t\t\t\t& ' as reported at ' & ReloadTime() & '. At an average of $(vs_analyzer_capacity_per_day) minutes used per day, you would' \r\n// \t\t\t\t\t\t\t\t\t\t\t\t& 'run out of minutes in $(vs_analyzer_capacity_run_out_days) days.'\r\n                                                & IF(vs_analyzer_capacity_run_out_days < 32,'run out of minutes in ' & $(vs_analyzer_capacity_run_out_days) & ' days.',' not run out of minutes before the new month starts and Analyzer Time is reset!')\r\n\t\t\t\t\t\t\t\t\t\t\t\t& '  Analyzer Capacity time resets the first day of each calendar month.';\r\n    Else\r\n      SET va_analyzer_capacity_message ='Analyzer Capacity Time not licensed or allocated.';\r\n    EndIf\r\n    \r\n  ELSE\t// Token-based license model\r\n\r\n    dim_dash:\r\n    LOAD * INLINE\r\n    [\r\n        dimNum, dimName\r\n        1, Total Users\r\n        2, Total Tokens Used\r\n        3, User Access Tokens Used\r\n        4, Login Access Tokens Used\r\n        5, Avg Daily Tokens Used\r\n        6, Max Daily Tokens Used\r\n        7, Access Denials      \r\n        8, Allocation Changes\r\n    ];\r\n    \r\n    SET va_analyzer_capacity_message ='Analyzer Capacity Time not licensed or allocated.';\r\n    \r\n  ENDIF\r\n\r\n  analyzer_capacity_message:\r\n  Load '$(va_analyzer_capacity_message)' as analyzer_capacity_message AutoGenerate 1;\r\n  Load '$(va_analyzer_capacity_help_link)' as analyzer_capacity_help_link AutoGenerate 1;\r\n  TRACE $(va_analyzer_capacity_message);\r\n  \r\n  REM For selecting a session count threshold for custom ELA usage analysis;\r\n  Let v_session_count_threshold = '=Max([session_count_threshold])';\r\n  session_count_threshold:\r\n  Load RowNo()+1 as session_count_threshold Autogenerate (11);\t// For session counts 2 through 12\r\n  Concatenate (session_count_threshold) Load 20 as session_count_threshold AutoGenerate 1;\r\n  Concatenate (session_count_threshold) Load 50 as session_count_threshold AutoGenerate 1;\r\n\r\n  // Limit Smart search to relevant fields\r\n  Search Include *;\r\n  Search Exclude [*Id],[dim*],[_*],[folder*],[*ort];\r\n  Search Include UserId;\r\n  \r\n  // For UI simplicity when making selections in the Allocation History page, these little tables are created\r\n  allocationUser:\r\n  NoConcatenate Load distinct UserId resident LogContent where [License Allocation]=1;\r\n  allocationMessage:\r\n  NoConcatenate Load distinct Message resident LogContent where [License Allocation]=1;\r\n  AllocationAffectedEntity:\r\n  NoConcatenate Load distinct [Affected Entity] resident LogContent where [License Allocation]=1;\r\n\r\n  \r\nENDSUB\r\n\r\n///$tab finalize\r\nSUB finalize\r\n  \r\n  If firstReload = 1 THEN\r\n     SET PriorReloadDuration = 0;\t\t// Initialize ReloadDuration for first reload\r\n  ELSE\r\n  \tLet PriorReloadDuration = ReloadDuration;  \r\n  END IF\r\n  \r\n  //// Set Reload Stats Variables\t//// \r\n  Let ReloadDuration = interval(now(1)-ReloadStartTime,'hh:mm:ss');\r\n  \r\n  IF storeBaseTableFail = 0 then\r\n      Let LastSuccessfulReloadStartTime = ReloadStartTime;\r\n  ELSE\r\n      Let LastSuccessfulReloadStartTime = LastReloadTime;\t// reset this to prior reload time\r\n  END IF\r\n\r\n// Monitor reload statistics\r\n  Let ttlRows \t\t= num(NoOfRows('LogContent'),'#,##0');\r\n  let hst\t\t\t= lower(ComputerName());\r\n  let ahora\t\t\t= now(1);\r\n  \r\n  // Check to see if there were any reload errors associated with this app; report them on the Log Details page\r\n  let reloadWarn\t= NoOfRows('monitor_app_reload_stats')-$(appMonitorStatsRowsInit)-1;\t// There will already be an 'reload start' entry in this table\r\n  let reloadWarnMsg\t= if(reloadWarn>1,' Reloaded with ' & reloadWarn & ' warning(s). Consult the License_Monitor_Reload_Stats.txt log for details.','');\r\nLET reloadWarnMsg\t= reloadWarnMsg & if(NumRowsQRS>0,'',msg_qrs);\t// Add error message if failure to fetch data from qrs\r\n  Let msg\t\t\t= 'Reloaded at $(ahora) on $(hst) for $(ReloadDuration) with $(ttlRows) log entries from $(logSource).$(reloadWarnMsg)';\r\n  \r\n  // Write final reload message and store App Reload Stats\r\n  CALL monitor_app_reload_stats('INFO','License Monitor',msg,'Reload Finish')\r\n\r\n  \r\nENDSUB\r\n\r\n///$tab RUN Logic\r\n//// Reload Logic  ////\r\n\r\nCALL monitor_app_reload_stats('INFO','License Monitor', startMsg,'Reload Start')\r\n\r\nLET baseTableName = '$(baseTableName)_file';\t\t// Store log history QVD with suffix _file so it only gets used with file logging\r\nTRACE Last Reload Compare time = $(lastReloadCompare). CutoffDate = $(cutoffDate).;\r\n\r\nREM Load the historical (incremental) QVD if it exists;\r\nCALL loadBaseTable ('LogContent', '$(baseTableName)')\t\t// Main License_Repository logs\r\nCALL loadBaseTable ('sessionData','$(sessionTableName)')\t// Session_Engine log for App Name\tTODO App Name for License\r\n\r\nREM table for commands;\r\nCALL CommandList\r\n\r\nREM initialize working tables;\r\nworking:\r\nLoad * inline [ProxyPackageId,RequestSequenceId]; \r\nworking_session:\r\nNoConcatenate Load * Inline [ProxySessionId, LogTimeStamp]; \r\n\r\nREM The log source (file or database) determines how the log data are loaded, which is defined next;\r\n\r\nCALL logList\r\nCALL defineFields\r\nCALL multiNodeConfig\r\nCALL logFolderList\r\n// This loops through the Sense\\Log folder on the central node + each [hostname] folder in the Sense\\Repository\\Archived Logs folder\r\nfor i = 0 to noofrows('logFolderList')-1\r\n  // Loop through each logfile enumerated in the logList SUB\r\n  FOR j = 0 to noofrows('logList')-1  \r\n    CALL loadFiles (i,j)\r\n  next j  \r\n  CALL sessionData (i)\r\nnext i\r\ndrop tables logList, logFolderList;\r\nSET logSource = 'Log Files';\r\nSET LastReloadSource = 1;\r\n\r\nLet rowsWorkingFinal = num(NoOfRows('working'),'#,##0');\r\ntrace $(rowsWorkingFinal) incremental rows loaded;\r\n \r\nCALL concatTables ('LogContent', 'working','Id')\r\nCALL storeFiles ('LogContent', '$(baseTableName)')\r\n\r\nLet sessionTableCount = NoOfRows('working_session');\r\nIF $(sessionTableCount) > 0 THEN\t// check sessionData for rows -- otherwise this reload will fail until there is at least one session\r\n  CALL concatTables ('sessionData', 'working_session','Id')\r\n  CALL storeFiles ('sessionData', '$(sessionTableName)')\r\n  Drop fields LogTimeStamp, Id from sessionData;\t// To avoid synthetic keys\r\n  \r\nELSEIF NoOfRows('sessionData') >0 then\r\n  Drop fields LogTimeStamp, Id from sessionData;\r\n  drop table working_session;\r\nELSE\r\n  trace No incremental session data (Open App) found. Skipping update.;\r\n  drop tables working_session, sessionData;\t\t// Drop these tables if no sessions to avoid synthetic keys\r\nEND IF\r\n\r\nCALL QRS\t\t// Call QRS data AFTER LogContent table is stored\r\n\r\nCALL qlikview_logs\t// For Unified Licensing of QlikView + Qlik Sense customers. This checks for QlikView Server logs in the monitor_apps_qlikview_logs data connection. No data = skip the script logic for dual-use\r\n\r\nCALL calendarization\r\nCALL supportingLogic\r\nCALL finalize\r\n"}}